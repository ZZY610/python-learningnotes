# python内置函数
## 1. 数学运算
### 1. abs()
> 返回数字的绝对值。参数可以是整数、浮点数或任何实现了 __abs__() 的对象。 如果参数是一个复数，则返回它的模。
```python
#--run--
# 参数可以是整数
print(f'{ abs(123) = }')
print(f'{ abs(-123) = }')
print(f'{ abs(0) = }')
# 参数可以是浮点数
print(f'{ abs(1.23) = }')
print(f'{ abs(-1.23) = }')
print(f'{ abs(0.0) = }')
# 参数可以任何实现了 __abs__() 的对象。
class TestClass:
    def __abs__(self):
        return 123
print(f'{ abs(TestClass()) = }')
# 如果参数是一个复数，则返回它的模
# 复数是实数+虚数
# 注意点：复数的绝对值返回值一定是浮点数
print(f'{ abs(3+4j) = }')
print(f'{ abs(-3-4j) = }')
```
### 2. pow()
* 格式：`pow(base, exp[, mod])`
* 返回值：int
> 返回 base 的 exp 次幂；如果 mod 存在，则返回 base 的 exp 次幂对 mod 取余（比 pow(base, exp) % mod 更高效）。 两参数形式 pow(base, exp) 等价于乘方运算符: base**exp
```python
# --run--
# 返回 base 的 exp 次幂；
print(f'{ pow(2, 3) = }')
print(f'{ pow(10, 2) = }')
# 两参数形式 pow(base, exp) 等价于乘方运算符: base**exp。
print(f'{ 2**3 = }')
print(f'{ 10**2 = }')
# 如果 mod 存在，则返回 base 的 exp 次幂对 mod 取余（比 pow(base, exp) % mod 更高效）

# 参数必须具有数值类型。 对于混用的操作数类型，则将应用双目算术运算符的类型强制转换规则。 对于 int 操作数，结果具有与操作数相同的类型（强制转换后），除非第二个参数为负值；在这种情况下，所有参数将被转换为浮点数并输出浮点数结果。 例如，10**2 返回 100，但 10**-2 返回 0.01。

# 参数必须具有数值类型
# print(f'{ pow(2, "3") = }')
# 对于混用的操作数类型，则将应用双目算术运算符的类型强制转换规则。
print(f'{ pow(2.0, 3) = }')
# 对于 int 操作数，结果具有与操作数相同的类型（强制转换后），除非第二个参数为负值；在这种情况下，所有参数将被转换为浮点数并输出浮点数结果。
print(f'{ pow(2, 3) = }')
print(f'{ pow(2, -3) = }')

# 对于 int 操作数 base 和 exp，如果给出 mod，则 mod 必须为整数类型并且 mod 必须不为零。 
# 如果给出 mod 并且 exp 为负值，则 base 必须相对于 mod 不可整除。 在这种情况下，将会返回 pow(inv_base, -exp, mod)，其中 inv_base 为 base 的倒数对 mod 取余。

# print(f'{ pow(2, 3, 0) = }')

# 下面的例子是 38 的倒数对 97 取余:
# >>> pow(38, -1, mod=97)
# 23
# >>> 23 * 38 % 97 == 1
# True
```

### 3. divmod()
* 格式：`divmod(a, b)`
* 返回值：一个包含商和余数的元组
> 它将两个（非复数）数字作为实参，并在执行整数除法时返回**一对商和余数**。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 (a // b, a % b) 一致。对于浮点数，结果是 (q, a % b) ，q 通常是 math.floor(a / b) 但可能会比 1 小。在任何情况下， q * b + a % b 和 a 基本相等；如果 a % b 非零，它的符号和 b 一样，并且 0 <= abs(a % b) < abs(b) 。

```python
#--run--
# 对于整数，结果和 (a // b, a % b) 一致。
a = 20  # 被除数
b = 3   # 除数
print(f'{ divmod(a, b) = }')#(6,2)
print(f'{ (a//b, a%b) = }')
# 对于浮点数，结果是 (q, a % b) ，q 通常是 math.floor(a / b)
import math
a = 2.0  # 被除数
b = 0.3  # 除数
q = math.floor(a/b)
print(f'{ divmod(a, b) = }')
print(f'{ (q, a%b) = }')
# 在任何情况下， q * b + a % b 和 a 基本相等
```
### 4. max()
* 格式：`max(iterable, *[, key, default])`    `max(arg1, arg2, *args[, key])`
* 返回值：可迭代对象中最大的元素，或者返回两个及以上实参中最大的序列。
> 如果只提供了一个位置参数，它必须是非空 iterable（单序列），返回可迭代对象中最大的**元素**；如果提供了两个及以上的位置参数（多序列），则返回最大的**位置参数（序列）**。
 单序列入参，返回序列中最大的一个数值。多序列入参, 按索引顺序，逐一对比各序列的当前索引位的 “值”，直到遇见最大值立即停止对比，并返回最大值所在的序列（也就是说，多序列入参，返回值依旧是一个序列，而不是数值）
```python
>>> max([1,2,3])
3
>>> max(1,2,4)
4
>>> max(-1, -0.5, 0)
0
>>> max((1,2,3))
3
>>> max([2,4], [3,6])
[3, 6]
>>> max([2,4], [1,5])
[2, 4]
>>> max([2,4], [1,5], [3,1], [2,5],[0,7])
[3, 1]
>>> max((1,2,3), (3,3,0))
(3, 3, 0)
>>> max((1,-1,0), (True,False,0)) #布尔喔
(True, False, 0)
>>> max((1,-1,0), (True,False,2,0),(1, 0, 0, 2))
(True, False, 2, 0)
>>> max((1,-1,0), (True,),(1,))
(1, -1, 0)
>>> max((-1,-1,0), (True,),(1,))
(True,)
>>> max([1,3,2],3,4) #非法入参
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: '>' not supported between instances of 'int' and 'list'
>>> max((1,2,3), [2,4,1]) #非法入参

```


> 有两个**可选**只能用关键字的实参。key 实参指定排序函数用的参数，如传给 list.sort() 的。default 实参是当可迭代对象为空时返回的值。如果可迭代对象为空，并且没有给 default ，则会触发 ValueError。
  如果有多个最大元素，则此函数将返回第一个找到的。
```python
print(max([],default=False)) #空表触发value error，设置default则不会。

# 给key传参
print(f'{ max([3, 9, -20, 15], key=abs) = }')
# 自定义函数作为key
import math
def fun1(x):
    return math.sin(x)
print(max([1,2,3,4,5,6],key=fun1))
'''
2
'''
# 如果有多个最大元素，则此函数将返回第一个找到的
print(f'{ max([3, 9, -20, 15, 20], key=abs) = }')

```

### 5. min()
* 格式：`min(iterable, *[, key, default])` `min(arg1, arg2, *args[, key])`
* 返回值：可迭代对象中最小的元素，或者返回两个及以上实参中最小的序列。

### 6. round()
* 格式：`round(number[, ndigits])`
* 返回值：返回 number 舍入到小数点后 ndigits 位精度的值。 如果 ndigits 被省略或为 None，则返回**最接近输入值的整数**。
> round()内置函数不是使用四舍五入的规则，而是根据距离远近的规则来取近似值。
> 即如果小于等于4则舍去，如果大于等于6则进入。如果5后面还有有效数字，则进1，如果5后面没有有效数字，则选择偶数。
```python
numbers = [-0.5, 0.5, 1.5, 2.5, 3.5]
for num in numbers:
    print(f'{ num = } { round(num) = }')
print(f'{ round(0.125, 2) = }')
print(f'{ round(0.51) = }')
print(f'{ round(0.1251, 2) = }')

'''
 num = -0.5  round(num) = 0
 num = 0.5  round(num) = 0
 num = 1.5  round(num) = 2
 num = 2.5  round(num) = 2
 num = 3.5  round(num) = 4
 round(0.115, 2) = 0.12
 round(0.51) = 1
 round(0.1251, 2) = 0.13
'''
```
> 任何整数值都可作为有效的 ndigits (正数、零或负数)。
```python
print(f'{ round(123.456, 2) = }')
print(f'{ round(123.456, 0) = }')
print(f'{ round(123.456, -2) = }')
print(f'{ round(163.456, -2) = }')

'''
 round(123.456, 2) = 123.46
 round(123.456, 0) = 123.0
 round(123.456, -2) = 100.0
 round(163.456, -2) = 200.0
'''
```
对浮点数执行 round() 的行为可能会令人惊讶：例如，round(2.675, 2) 将给出 2.67 而不是期望的 2.68。 这不算是程序错误：这一结果是由于大多数十进制小数实际上都不能以浮点数精确地表示。

### 7. sum()
* 格式：`sum(iterable, /, start=0)`
* 返回值：从 start 开始自左向右对 iterable 的项求和并返回总计值。 iterable 的项通常为数字，而 start 值则不允许为字符串。

```python
print(sum([1,2,3],start=10)) #计算总和后再加10
#16
```

### 8. sorted()
* 格式： `sorted(iterable, *, key=None, reverse=False)`
* 返回值： 根据 iterable 中的项返回一个新的已排序列表。
> 具有两个可选参数，它们都必须指定为关键字参数。reverse=False reverse 次序颠倒 在这里表示，是否倒序排序，默认为False，表示默认升序排序.

```python
# --run--
print(f'{ sorted(["b", "c", "a"]) = }')
print(f'{ sorted((2, 3, 1)) = }')
print(f'{ sorted("bca") = }')
'''
sorted(["b", "c", "a"]) = ['a', 'b', 'c']
sorted((2, 3, 1)) = [1, 2, 3]
sorted("bca") = ['a', 'b', 'c']
'''
```
key 指定带有**单个参数的函数**，用于从 iterable 的每个元素中提取用于比较的键 (例如 key=str.lower)。 默认值为 None (直接比较元素)。
```python
student_scores = [('A', 99), ('B', 114), ('C', 86)]
def get_key(elem):
    return elem[1]
print(f'{ sorted(student_scores, key=get_key) = }')
print(f'{ sorted(student_scores, key=lambda elem: elem[1]) = }')
# [('C', 86), ('A', 99), ('B', 114)]
# [('C', 86), ('A', 99), ('B', 114)]
```


## 2. 输入输出

### 9. input()
* 格式： `input([prompt])`
* 返回值： str
> 如果存在 prompt 实参，则将其写入标准输出，末尾不带换行符。该函数从输入中读取一行，将其转换为字符串（除了末尾的换行符）并返回。
```python
prompt = '请输入内容:'
line = input(prompt)
print(f'{ line=  } { type(line) = }')

# 请输入内容:today
#  line=  'today'  type(line) = <class 'str'>
```
input() 函数的参数只能为单个字符串。常用int()将输入的字符串转为整数类型。


### 10. print()
* 格式： `print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)`
* 返回值：None

参数说明：
| 参数 | 类型 | 说明 |
| -- | -- | -- |
| objects | str等 | 可以一次输出多个对象。输出多个对象时，需要用 `,` 分隔。 |
| sep | str | 用来间隔多个对象，默认值是一个空格。 |
| end | str | 用来设定以什么结尾。默认值是换行符 \n，可以换成其他字符串。 |
| file |  | 要写入的文件对象。 |
| flush | bool | 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。 |
```python
x1=[x**2 for x in range(0,6)]
for x in x1:
    print(x,end="+")

# 0+1+4+9+16+25+
```


## 3. 文件操作
### 11.open()
* 格式： **open**(`file`, `mode='r'`, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
* 返回值： file object,如果无法打开会会抛出 OSError。
>  open() 函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数。

参数说明：
| 参数 | 类型 | 说明 |
| -- | -- | -- |
| ***file*** | str | 必需，文件路径（相对或者绝对路径） |
| ***mode***| str | 可选，指定文件打开模式 |
| buffering | int | 可选，设置缓冲 |
| encoding | str | 文件编码方式，一般使用utf-8 |
| errors | str | 可选，指定如何处理错误  |
| newline |  | 区分换行符 |
| closefd |  | 传入的file参数类型 |
| opener |  |  |

mode可选参数：
| 参数 | 描述 |
| -- | -- |
| t | 文本模式（默认） |
| x | 写模式，新建一个文件，如果该文件已存在则会报错。 |
| b | 二进制模式 |
| a | 追加写。若文件已存在，文件指针将会放在文件的结尾；新的内容将会被写入到已有内容之后。若文件不存在，创建新文件写入。 |
| r | 打开并读取文本。文件的指针将会放在文件的开头。（默认）与rt同义 |
| w | 打开文件只用于写入（原有内容会被删除）。若文件不存在则创建新文件。 |
| + | 打开一个文件进行更新(可读可写)。 |

```python
s=open(r"C:\Users\zzy\Desktop\test.txt",
       "r",
       encoding="utf-8")

def fun1():#这个函数用来统计文本中的高频词，返回一个“词-频”对的字典
    counts={}
    x = jieba.lcut(s.read())
    for word in x:
        if len(word)==1:
            pass
        else:
            counts[word]=counts.get(word,0)+1
    items=list(counts.items())
    items.sort(key=lambda x:x[1],reverse=True)
    return dict(items)
```

## 4. 进制转换
### 12. bin()
* 格式：
* 返回值： str
> 将一个**整数**转变为一个前缀为“0b”的二进制**字符串**。

### 13. hex()
* 格式：
* 返回值： str
> 将**整数**转换为以“0x”为前缀的小写十六进制**字符串**。

### 14. oct()
* 格式：
* 返回值： str
> 将一个**整数**转变为一个前缀为“0o”的八进制**字符串**。

## 5. unicode字符
### 15. chr()
* 格式：
* 返回值：
> 返回 Unicode 码位为整数 i 的字符的字符串格式。
```python
print(chr(36530)) #躲
```


### 16. ord()
* 格式： `ord(c)`
* 返回值：
> 对表示单个 Unicode 字符的字符串，返回代表它 Unicode 码点的整数。
```python
print(ord("躲")) #36530
```


## 6. 类型转换
### 17. bool()
* 格式： `class bool([x])`
* 返回值： 返回一个布尔值，True 或者 False。
> x 使用标准的真值测试过程来转换。如果 x 是假的或者被省略，返回 False；其他情况返回 True。bool 类是 int 的子类（参见数字类型---int, float, complex）。其他类不能继承自它。它只有 False 和 True 两个实例（参见 布尔值）。
```python
#--run--
print(f'{ bool() = }')
print(f'{ bool(None) = }')
print(f'{ bool(False) = }')

from decimal import Decimal
from fractions import Fraction
print(f'{ bool(0) = }')
print(f'{ bool(0.0) = }')
print(f'{ bool(0j) = }')
print(f'{ bool(Decimal(0)) = }')
print(f'{ bool(Fraction(0, 1)) = }')
print('-'*20)
print(f'{ bool("") = }')
print(f'{ bool(()) = }')
print(f'{ bool([]) = }')
print(f'{ bool({}) = }')
print(f'{ bool(set()) = }')
print(f'{ bool(range(0)) = }')
# 如果 x 是假的或者被省略，返回 False；其他情况返回 True。
print(f'{ bool(123) = }')
print(f'{ bool(1.23) = }')
print(f'{ bool("test") = }')

# bool() = False
# bool(None) = False
# bool(False) = False
# bool(0) = False
# bool(0.0) = False
# bool(0j) = False
# bool(Decimal(0)) = False
# bool(Fraction(0, 1)) = False
# --------------------
# bool("") = False
# bool(()) = False
# bool([]) = False
# bool({}) = False
# bool(set()) = False
# bool(range(0)) = False
# bool(123) = True
# bool(1.23) = True
# bool("test") = True
```




### 18. int()
* 格式： `int(*x*,base=10)`
* 返回值： 返回一个基于**数字**或**字符串x**构造的整数int对象，或者在未给出参数时返回 0。对浮点数向下取整。

> 这个函数按照base进制对数x进行解释，返回一个使用数字或字符串生成的**整数**int对象，无实参返回0。
> 其中**x**为**数字或字符串**，**base**为进制，取值范围为[2，36]和0。
> 一个进制为n的整数包含0到n-1的整数，其中a-z(A-Z)表示10到35。
进制为0将会按照代码字面的**前缀**进行解释，结果是2、8、10、16中的一个。

要清楚的一点是，在python中带有前缀的数字，例如0xa，0o12，0b1010它们的`类型(type)`都是int整数类型。
如果想知道它们十进制数值，可以直接print，或print(int(x))，也可以int(str(x),base=0)（？）.

对这个函数的使用，主要分为三种情况：    
* x为int类型：无论带不带前缀，这个数的进制已经清楚，该函数无法对一个**进制清楚**的**非字符串类型**进行转换（启用base关键字）。
* x为str字符串类型：
  * 带前缀：表明这个数的进制已经清楚，base只能等于其前缀或0。
  * 不带前缀：根据用法自由发挥。注意没有前缀且令base=0的话应注意x其形式。比如int("010",base=0)是非法的。因为解释器认为x是十进制数，但x形式是错误的。
* x为byte类型：暂时空缺。

```python
# --run--
x=int(156,base=2) #报错
x=int(0x156,base=0) #报错

x1="0101" #字符串
y1=int(x1,base=2) # 结果为整数5
y2=int(x1,base=8) # 结果为整数65
y3=int(x1,base=16) # 结果为整数257
y4=int(x1,base=35) # 结果为整数1226

x2="0xa5f1"
y5=int(x,base=16) # 结果为整数42481
y6=int(x,base=0) # 结果为整数42481

```

### 19. float()
* 格式： class float([x])
* 返回值： 返回从数字或字符串 x 生成的浮点数。
> 如果实参是字符串，则它必须是包含十进制数字的字符串，字符串前面可以有符号，之前也可以有空格。可选的符号有 '+' 和 '-' ； '+' 对创建的值没有影响。

```python
print(f'{ float("1.23") = }')
print(f'{ float("+1.23") = }')
print(f'{ float("-1.23") = }')
print(f'{ float("    -1.23") = }')

'''
float("1.23") = 1.23
float("+1.23") = 1.23
float("-1.23") = -1.23
float("    -1.23") = -1.23
'''
```
如果实参是整数或浮点数，则返回具有相同值（在 Python 浮点精度范围内）的浮点数。如果实参在 Python 浮点精度范围外，则会触发 OverflowError。
如果没有实参，则返回 0.0 
```python
>>> float('+1.23')
1.23
>>> float('   -12345\n')
-12345.0
>>> float('1e-003')
0.001
>>> float('+1E6')
1000000.0
>>> float('-Infinity')
-inf
```


### 20. range()

* 格式： 

        class range(stop)
        class range(start, stop[, step])
* 返回值：range 类型
> range 构造器的参数必须为整数。如果省略 step 参数，其默认值为 1。 如果省略 start 参数，其默认值为 0，如果 step 为零则会引发 ValueError。

如果 `step` 为正值，确定 range 内容的公式为 r[i] = start + `step` * i 其中 i >= 0 且 r[i] < stop。

如果 `step` 为负值，确定 range 内容的公式仍然为 r[i] = start + `step` * i，但限制条件改为 i >= 0 且 r[i] > stop.

如果 r[0] 不符合值的限制条件，则该 range 对象为空。 range 对象确实支持负索引，但是会将其解读为从正索引所确定的序列的末尾开始索引。

```python
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list(range(1, 11))
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> list(range(0, 30, 5))
[0, 5, 10, 15, 20, 25]
>>> list(range(0, 10, 3))
[0, 3, 6, 9]
>>> list(range(0, -10, -1))
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
>>> list(range(0))
[]
>>> list(range(1, 0))
[]
```

### 21. list()
* 格式：
    
        class list([iterable])
* 返回值： 构造器将构造一个列表，其中的项与 iterable 中的项具有相同的的值与顺序。 iterable 可以是序列、支持迭代的容器或其它可迭代对象。

::: tip 创建列表的几种方式
1.  方括号直接赋值：
   ```python
    x=[]
    y=[1,"one",("jack")]
   
   ```
2.  列表推导式:
   ```python
   [x**2 for x in range(0,10,2)]
   ```
   
3.  类型构造器`list()`函数：
   ```python
   x=list("abcdefg")
   x1=list((1,2,3))
   
   ```
:::
如果没有给出参数，构造器将创建一个空列表 []。

---



### 22. dict()
* 格式：

        class dict(**kwarg)
        class dict(mapping, **kwarg)
        class dict(iterable, **kwarg)
* 参数说明： 
    * **kwargs -- 关键字。
    * mapping -- 元素的容器，映射类型（Mapping Types）是一种关联式的容器类型，它存储了对象与对象之间的映射关系。
    * iterable -- 可迭代对象。
* 返回值：返回一个新的字典，基于可选的位置参数和可能为空的关键字参数集来初始化。
::: tip 创建字典的几种方式
1.  大括号直接赋值：
   ```python
   dict1 = {}
   dict1['chinese'] = 100
   dict1['math'] = 80
   
   dict1 = {'firstname':'ma', 'lastname':'yun'}
   ```
2.  字典推导式:
   ```python
   def fun(x):
    return x**3
   y={x:fun(x) for x in range(0,6)}
   # {0: 0, 1: 1, 2: 8, 3: 27, 4: 64, 5: 125}
   ```
   
3.  类型构造器`dict()`函数：
   ```python
   x=dict({"one": 1, "two": 2, "three": 3})
   print(x)
   ```
:::

> 如果给出一个位置参数并且其属于映射对象，将创建一个具有与映射对象相同键值对的字典。
    
    print(f'{ dict({"one": 1, "two": 2, "three": 3}) = }')
> 否则的话，位置参数必须为一个 iterable 对象。
> 该可迭代对象中的**每一项**本身必须为一个刚好**包含两个元素**的可迭代对象。
> 每一项中的第一个对象将成为新字典的一个键，第二个对象将成为其对应的值。
```python
x=dict([("one",1),("two",2)])
y=dict((["one",1],["two",2]))
```

> 如果一个键出现一次以上，该键的最后一个值将成为其在新字典中对应的值。
> 如果给出了关键字参数，则关键字参数及其值会被加入到基于位置参数创建的字典。
> 如果要加入的键已存在，来自关键字参数的值将替代来自位置参数的值。
```python
print(f'{ dict(one=1, two=2, three=3) = }')
print(f'{ dict({"two": 2, "three": 3}, one=1) = }')
print(f'{ dict({"one": 11, "two": 2, "three": 3}, one=1) = }')
```

### 23. tuple()
* 格式： class tuple([iterable])
* 返回值： 构造器将构造一个元组，其中的项与 iterable 中的项具有相同的值与顺序。
::: tip 构造元组的几种方式
1. 圆括号直接赋值：
```python
x=(1,)#使用一个后缀的逗号来表示单元组
x=(1,2,3)#使用以逗号分隔的多个项
```

2. tuple()函数
```python
print(f'{ tuple(["a", "b", "c"]) = }')
print(f'{ tuple(("a", "b", "c")) = }')
print(f'{ tuple(range(3)) = }')
print(f'{ tuple("abc") = }')

# tuple(["a", "b", "c"]) = ('a', 'b', 'c')
# tuple(("a", "b", "c")) = ('a', 'b', 'c')
# tuple(range(3)) = (0, 1, 2)
# tuple("abc") = ('a', 'b', 'c')
```

:::
注意决定生成元组的其实是逗号而不是圆括号。 圆括号只是可选的，生成空元组或需要避免语法歧义的情况除外。 例如，f(a, b, c) 是在调用函数时附带三个参数，而 f((a, b, c)) 则是在调用函数时传参三元组。

### 24. set()
* 格式： class set([iterable])
* 返回值： 返回一个新的 set 或 frozenset 对象，其元素来自于 iterable。 集合的元素必须为 hashable。 要表示由集合对象构成的集合，所有的内层集合必须为 frozenset 对象。 如果未指定 iterable，则将返回一个新的空集合。
```python
print(f'{ set(["a", "b", "c"]) = }')
print(f'{ set(["a", "b", "c", "a"]) = }')
print(f'{ set(("a", "b", "c")) = }')
print(f'{ set(range(3)) = }')
print(f'{ set("abc") = }')

# set(["a", "b", "c"]) = {'b', 'c', 'a'}
# set(["a", "b", "c", "a"]) = {'b', 'c', 'a'}
# set(("a", "b", "c")) = {'b', 'c', 'a'}
# set(range(3)) = {0, 1, 2}
# set("abc") = {'b', 'c', 'a'}
```


### 25. str()
* 格式：

        class str(object='')
        class str(object=b'', encoding='utf-8', errors='strict')
* 返回值：返回 object的字符串版本。 如果未提供 object 则返回空字符串。
> 如果 encoding 或 errors 均未给出，str(object) 返回 object.__str__()，这是 object 的“非正式”或格式良好的字符串表示。 对于字符串对象，这是该字符串本身。 如果 object 没有 __str__() 方法，则 str() 将回退为返回 repr(object)。
```python
print(f'{ str(123) = }')
print(f'{ str([1, 2, 3]) = }')
print(f'{ str(range(3)) = }')
print(f'{ str("test") = }')

# str(123) = '123'
# str([1, 2, 3]) = '[1, 2, 3]'
# str(range(3)) = 'range(0, 3)'
# str("test") = 'test'
```

### 26. complex()
* 格式：class complex([real[, imag]])
* 返回值： 返回值为` real + imag*1j `的复数，或将字符串或数字转换为复数。
> 如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时必须没有第二个形参。第二个形参不能是字符串。

    print(f'{ complex("1+2j") = }')
    # complex("1+2j") = (1+2j)
> 每个实参都可以是任意的数值类型（包括复数）。如果省略了 imag，则默认值为零，构造函数会像 int 和 float 一样进行数值转换。如果两个实参都省略，则返回 0j。
```python
print(f'{ complex(1, 2) = }')
print(f'{ complex(1, -2) = }')
print(f'{ complex(1.2, 3.4) = }')
print(f'{ complex(1+2j, 1) = }')
print(f'{ complex(1+2j, 1+2j) = }')

'''
complex(1, 2) = (1+2j)
complex(1, -2) = (1-2j)
complex(1.2, 3.4) = (1.2+3.4j)
complex(1+2j, 1) = (1+3j)
 complex(1+2j, 1+2j) = (-1+3j)
'''
```

### 27. bytearray()
* 格式：class bytearray([source[, encoding[, errors]]])
* 返回值：返回一个新的 bytes 数组。 bytearray 类是一个可变序列，包含范围为 0 <= x < 256 的整数。它有可变序列大部分常见的方法，见 可变序列类型 的描述；同时有 bytes 类型的大部分方法，参见 bytes 和 bytearray 操作。

```python
返回一个新的 bytes 数组。
可选形参 source 可以用不同的方式来初始化数组：

如果是一个 string，您必须提供 encoding 参数（errors 参数仍是可选的）；bytearray() 会使用 str.encode() 方法来将 string 转变成 bytes。
print(f'{ bytearray("test", "utf-8") = }')
print(f'{ type(bytearray("test", "utf-8")) = }')
print(f'{ "test".encode("utf-8") = }')
print(f'{ type("test".encode("utf-8")) = }')
print('-------------')
print(f'{ bytearray("test", "utf-8", "strict") = }')
print(f'{ "test".encode("utf-8", "strict") = }')

如果是一个 integer，会初始化大小为该数字的数组，并使用 null 字节填充。
print('--------------')
print(f'{ bytearray(3) = }')

如果是一个遵循 缓冲区接口 的对象，该对象的只读缓冲区将被用来初始化字节数组。
print('------------')
bytes_object = "test".encode("utf-8")
print(f'{ bytearray(bytes_object) = }')

如果是一个 iterable 可迭代对象，它的元素的范围必须是 0 <= x < 256 的整数，它会被用作数组的初始内容。
print('--------------')
print(f'{ bytearray([10, 65, 97, 98, 99]) = }')
print(f'{ bytearray([256, 257]) = }')

如果没有实参，则创建大小为 0 的数组。
print('-----------------')
print(f'{ bytearray() = }')
```
另见 二进制序列类型 --- bytes, bytearray, memoryview 和 bytearray 对象

### 28. bytes()
* 格式：class bytes([source[, encoding[, errors]]])
* 返回值：返回一个新的“bytes”对象， 是一个不可变序列，包含范围为 0 <= x < 256 的整数。bytes 是 bytearray 的不可变版本 - 它有其中不改变序列的方法和相同的索引、切片操作。
因此，构造函数的实参和 bytearray() 相同。

```python
返回一个新的“bytes”对象，构造函数的实参和 bytearray() 相同。
如果source参数是一个字符串，必须提供encoding参数
print(f'{ bytes("test", "utf-8") = }')
print(f'{ type(bytes("test", "utf-8")) = }')
如果source是一个整型，会初始化大小为该数字的数组，并使用null字节填充
print('--------')
print(f'{ bytes(3) = }')
如果source是一个遵循 缓冲区接口 的对象，该对象的只读缓存区将被用来初始化字节数组
print('----------')
bytearray_object = bytearray('test', 'utf-8')
print(f'{ bytes(bytearray_object) = }')

如果source参数是一个iterable可迭代对象，它会被用作数组的初始化内容
print('------')
print(f'{ bytes([65, 66, 67]) = }')
如果没有实参，则创建大小为0的数组
print('------')
print(f'{ bytes() = }')
字节对象还可以用字面值创建，参见 字符串和字节串字面值。

字节对象还可以用字面值创建
print('---------')
print(f'{ bytes("test", "utf-8") = }')
print(f'{ b"test" = }')
print(f'{ type(b"test") = }')
```

另见 二进制序列类型 --- bytes, bytearray, memoryview，bytes 对象 和 bytes 和 bytearray 操作。

### 29. frozenset()

* 格式：class frozenset([iterable])
* 返回值：返回一个新的 set 或 frozenset 对象，其元素来自于 iterable。 集合的元素必须为 hashable。 要表示由集合对象构成的集合，所有的内层集合必须为 frozenset 对象。 如果未指定 iterable，则将返回一个新的空集合。

>frozenset() 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。

```python
返回一个新的 frozenset 对象，其元素来自于 iterable。
print(f'{ frozenset(["a", "b", "c"]) = }')
print(f'{ frozenset(["a", "b", "c", "a"]) = }')
print(f'{ frozenset(("a", "b", "c")) = }')
print(f'{ frozenset(range(3)) = }')
print(f'{ frozenset("abc") = }')
如果未指定 iterable，则将返回一个新的空集合。
print('--------')
print(f'{ frozenset() = }')
```


集合可用多种方式来创建:

使用花括号内以逗号分隔元素的方式: {'jack', 'sjoerd'}

使用集合推导式: `{c for c in 'abracadabra' if c not in 'abc'}
`
使用类型构造器: set(), set('foobar'), set(['a', 'b', 'foo'])

### 30. memoryview()

class memoryview(obj)
创建一个引用 obj 的 memoryview。 obj 必须支持缓冲区协议。 支持缓冲区协议的内置对象包括 bytes 和 bytearray。
```python
#--run--
print(f'{ memoryview(b"abcdef") = }')
print(f'{ memoryview(bytes("abcdef", "utf-8")) = }')
print(f'{ memoryview(bytearray("abcdef", "utf-8")) = }')
print('-------')
print(f'{ hasattr(memoryview, "__len__") = }')
print(f'{ hasattr(memoryview, "__getitem__") = }')
print('-----------')
print(f'{ memoryview(b"abcdef")[0] = }')
print(f'{ memoryview(b"abcdef")[1] = }')
print('-----------')
print(f'{ memoryview(b"abcdef")[0:3] = }')
print(f'{ bytes(memoryview(b"abcdef")[0:3]) = }')
```

memoryview 具有 元素 的概念，即由原始对象 obj 所处理的基本内存单元。 对于许多简单类型例如 bytes 和 bytearray 来说，一个元素就是一个字节，但是其他的类型例如 array.array 可能有更大的元素。

len(view) 与 tolist 的长度相等。 如果 view.ndim = 0，则其长度为 1。 如果 view.ndim = 1，则其长度等于 view 中元素的数量。 对于更高的维度，其长度等于表示 view 的嵌套列表的长度。 itemsize 属性可向你给出单个元素所占的字节数。
memoryview 支持通过切片和索引访问其元素。 一维切片的结果将是一个子视图:
```python
>>>
>>> v = memoryview(b'abcefg')
>>> v[1]
98
>>> v[-1]
103
>>> v[1:4]
<memory at 0x7f3ddc9f4350>
>>> bytes(v[1:4])
b'bce'
如果 format 是一个来自于 struct 模块的原生格式说明符，则也支持使用整数或由整数构成的元组进行索引，并返回具有正确类型的单个 元素。 一维内存视图可以使用一个整数或由一个整数构成的元组进行索引。 多维内存视图可以使用由恰好 ndim 个整数构成的元素进行索引，ndim 即其维度。 零维内存视图可以使用空元组进行索引。

这里是一个使用非字节格式的例子:

>>>
>>> import array
>>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])
>>> m = memoryview(a)
>>> m[0]
-11111111
>>> m[-1]
44444444
>>> m[::2].tolist()
[-11111111, -33333333]
如果下层对象是可写的，则内存视图支持一维切片赋值。 改变大小则不被允许:

>>>
>>> data = bytearray(b'abcefg')
>>> v = memoryview(data)
>>> v.readonly
False
>>> v[0] = ord(b'z')
>>> data
bytearray(b'zbcefg')
>>> v[1:4] = b'123'
>>> data
bytearray(b'z123fg')
>>> v[2:3] = b'spam'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: memoryview assignment: lvalue and rvalue have different structures
>>> v[2:6] = b'spam'
>>> data
bytearray(b'z1spam')
由带有格式符号 'B', 'b' 或 'c' 的可哈希（只读）类型构成的一维内存视图同样是可哈希的。 哈希定义为 hash(m) == hash(m.tobytes()):

>>>
>>> v = memoryview(b'abcefg')
>>> hash(v) == hash(b'abcefg')
True
>>> hash(v[2:4]) == hash(b'ce')
True
>>> hash(v[::-2]) == hash(b'abcefg'[::-2])
True
在 3.3 版更改: 一维内存视图现在可以被切片。 带有格式符号 'B', 'b' 或 'c' 的一维内存视图现在是可哈希的。

在 3.4 版更改: 内存视图现在会自动注册为 collections.abc.Sequence

在 3.5 版更改: 内存视图现在可使用整数元组进行索引。
```


## 7. 格式化输出

### 31. format
* 格式：format(value[, format_spec])
* 返回值：将 value 转换为 format_spec 控制的“格式化”表示。返回字符串。
> format_spec 的解释取决于 value 实参的类型，但是大多数内置类型使用标准格式化语法：格式规格迷你语言。
```python
# format(value[, format_spec])
# 将 value 转换为 format_spec 控制的“格式化”表示。format_spec 的解释取决于 value 实参的类型，但是大多数内置类型使用标准格式化语法：格式规格迷你语言。
print(f'{ format("test", "<10") = }')
print(f'{ format("test", "^10") = }')
print(f'{ format("test", ">10") = }')
print('--------')
print(f'{ format(10, "b") = }')
print(f'{ format(10, "o") = }')
print(f'{ format(10, "d") = }')
print(f'{ format(10, "x") = }')
print('--------')
print(f'{ format(10, "#x") = }')
print(f'{ format(10, "#X") = }')
print('-------------')
print(f'{ format(1, "0>4") = }')
print(f'{ format(12, "0>4") = }')
print(f'{ format(123, "0>4") = }')
print(f'{ format(1234, "0>4") = }')
print('----------')
print(f'{ format(3.1415926, ".2f") = }')
print(f'{ format(0.967, ".2%") = }')

# format("test", "<10") = 'test      '
# format("test", "^10") = '   test   '
# format("test", ">10") = '      test'
# --------
# format(10, "b") = '1010'
# format(10, "o") = '12'
# format(10, "d") = '10'
# format(10, "x") = 'a'
# --------
# format(10, "#x") = '0xa'
# format(10, "#X") = '0XA'
# -------------
# format(1, "0>4") = '0001'
# format(12, "0>4") = '0012'
# format(123, "0>4") = '0123'
# format(1234, "0>4") = '1234'
# ----------
# format(3.1415926, ".2f") = '3.14'
# format(0.967, ".2%") = '96.70%'

```
格式控制符和字符串的format方法详见字符串格式化输出。

## 8. 可迭代对象、迭代器
### 32. all()
all(iterable)
如果 iterable 的所有元素均为真值（或可迭代对象为空）则返回 True 。 等价于:

def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
如果 iterable 的所有元素均为真值（或可迭代对象为空）则返回 True 。
from decimal import Decimal
from fractions import Fraction
print(f'{ all([True, 123, 1.23, "test"]) = }')
print(f'{ all([(1, 2), [1, 2], {"name": "小明"}, {"a", "b"}, range(3)]) = }')
print(f'{ all([1+2j, Decimal("1.23"), Fraction(1, 2)]) = }')
print(f'{ all([]) = }')
print(f'{ all(()) = }')
如果可迭代对象不为空，只要有一个元素为假值，则返回False
print(f'{ all([True, 123, 1.23, ""]) = }')
print(f'{ all([(), [1, 2], {"name": "小明"}, {"a", "b"}, range(3)]) = }')
print(f'{ all([1+2j, Decimal("0.0"), Fraction(1, 2)]) = }')

### 33. any()
any(iterable)
如果 iterable 的任一元素为真值则返回 True。 如果可迭代对象为空，返回 False。 等价于:

def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
from decimal import Decimal
from fractions import Fraction
如果 iterable 的任一元素为真值则返回 True。
iterable = [None, False, 0, 0.0, 0j, Decimal("0.0"), Fraction(0, 1), "test", (), [], {}, set(), range(0)]
print(f'{ any(iterable) = }')
如果可迭代对象为空，返回 False。
print(f'{ any([]) = }')
print(f'{ any(()) = }')
如果可迭代对象不为空，并且iterable的所有元素都为假值，则返回False
iterable = [None, False, 0, 0.0, 0j, Decimal("0.0"), Fraction(0, 1), "", (), [], {}, set(), range(0)]
print(f'{ any(iterable) = }')

### 34. enumerate()
enumerate(iterable, start=0)
枚举
enumerate
返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。 enumerate() 返回的迭代器的 __next__() 方法返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。

返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。
print(f'{ enumerate("abc") = }')
print(f'{ enumerate(iter("abc")) = }')
print(f'{ enumerate(["a", "b", "c"]) = }')
 enumerate() 返回的迭代器的 __next__() 方法返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。
print('--------------')
iterable = ["a", "b", "c"]
enum = enumerate(iterable, start=0)
print(f'{ enum = }')
print(f'{ enum.__next__() = }')
print(f'{ enum.__next__() = }')
print(f'{ enum.__next__() = }')
print('------------')
print(f'{ list(enumerate(["a", "b", "c"], start=0)) = }')
print(f'{ list(enumerate(["a", "b", "c"], start=3)) = }')
print(f'{ list(enumerate(["a", "b", "c"], start=100)) = }')
print('--------------')
students = ['小明', '小红', '小灰']
需求：输出第几个学生是某某某
i = 0
for student in students:
    print(f'第{i+1}个学生是{student}')
    i += 1
print('--------------')
for i, student in enumerate(students, start=0):
    print(f'第{i+1}个学生是{student}')
print('--------------')
for i, student in enumerate(students, start=1):
    print(f'第{i}个学生是{student}')
>>>
seasons = ['Spring', 'Summer', 'Fall', 'Winter']
list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
等价于:

def enumerate(sequence, start=0):
    n = start
    for elem in sequence:
        yield n, elem
        n += 1

### 35. map()
* 格式： map(function, iterable, ...)
* 返回值： 返回一个将 function 应用于 iterable 中每一项并输出其结果的迭代器。 

如果传入了额外的 iterable 参数，function 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。 
当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。 对于函数的输入已经是参数元组的情况，请参阅 itertools.starmap()。
```python
#返回一个将 function 应用于 iterable 中每一项并输出其结果的迭代器。
def func(elem):
    return elem**2
print(f'{ map(func, [1, 2, 3]) = }')
print(f'{ list(map(func, [1, 2, 3])) = }')
print(f'{ tuple(map(func, [1, 2, 3])) = }')
print(f'{ set(map(func, [1, 2, 3])) = }')
for elem in map(func, [1, 2, 3]):
    print(elem)
#如果传入了额外的 iterable 参数，function 必须接受相同个数的实参并被应用于从所有可迭代对象中并行获取的项。
def func(iterable1_elem, iterable2_elem):
    return iterable1_elem + iterable2_elem
print(f'{ map(func, [1, 2, 3], [4, 5, 6]) = }')
print(f'{ list(map(func, [1, 2, 3], [4, 5, 6])) = }')
#当有多个可迭代对象时，最短的可迭代对象耗尽则整个迭代就将结束。
def func(iterable1_elem, iterable2_elem, iterable3_elem):
    return iterable1_elem + iterable2_elem + iterable3_elem
print(f'{ map(func, ["a", "b", "c"], ["a", "b"], ["a"]) = }')
print(f'{ list(map(func, ["a", "b", "c"], ["a", "b"], ["a"])) = }')

```

### 36. filter()

* 格式：filter(function, iterable)

用 iterable 中函数 function 返回真的那些元素，构建一个新的迭代器。iterable 可以是一个序列，一个支持迭代的容器，或一个迭代器。如果 function 是 None ，则会假设它是一个身份函数，即 iterable 中所有返回假的元素会被移除。


```python
def func(elem):
    return elem in ['a', 'b', 'c', 'd', 'e']
print(f'{ filter(func, "apple") = }')
print(f'{ type(filter(func, "apple")) = }')
print(f'{ list(filter(func, "apple")) = }')
print(f'{ tuple(filter(func, "apple")) = }')
print(f'{ set(filter(func, "apple")) = }')
for elem in filter(func, "apple"):
    print(elem)
# iterable 可以是一个序列，一个支持迭代的容器，或一个迭代器。
def func(elem):
    return elem % 2 == 0
print(f'{ filter(func, [0, 1, 2, 3, 4, 5]) = }')
print(f'{ list(filter(func, [0, 1, 2, 3, 4, 5])) = }')
# iterable 可以是一个序列，一个支持迭代的容器，或一个迭代器。
def func(elem):
    return elem % 2 == 0
iterator = iter([0, 1, 2, 3, 4, 5])
print(f'{ filter(func, iterator) = }')
print(f'{ list(filter(func, iterator)) = }')
# 如果 function 是 None ，则会假设它是一个身份函数，即 iterable 中所有返回假的元素会被移除。
print(f'{ list(filter(None, [None, False, 0, 0.0, 1, "test", ""])) = }')

请注意， filter(function, iterable) 相当于一个生成器表达式，当 function 不是 None 的时候为 (item for item in iterable if function(item))；function 是 None 的时候为 (item for item in iterable if item) 。
```

请参阅 itertools.filterfalse() 了解，只有 function 返回 false 时才选取 iterable 中元素的补充函数


### 37. zip()
* 格式： `zip(*iterables)`
* 返回值： class 'zip',返回一个**元组**的迭代器，其中的第 i 个元组包含来自每个参数序列或可迭代对象的第 i 个元素。
> 创建一个聚合了来自每个可迭代对象中的元素的迭代器。
```python
x=[1,2,3]
y=(4,5,6)
z="789"
zipped=zip(x,y,z)
print(list(zipped))

'''
[(1, 4, '7'), (2, 5, '8'), (3, 6, '9')]
'''
print(f'{ zip([1, 2, 3], ("a", "b", "c"), range(3)) = }')
print(f'{ list(zip([1, 2, 3], ("a", "b", "c"), range(3))) = }')
'''
zip([1, 2, 3], ("a", "b", "c"), range(3)) = <zip object at 0x000001FEB14B5480>
list(zip([1, 2, 3], ("a", "b", "c"), range(3))) = [(1, 'a', 0), (2, 'b', 1), (3, 'c', 2)]
'''
```
> 当所输入可迭代对象中最短的一个被耗尽时，迭代器将停止迭代。

    print(f'{ list(zip([1, 2, 3], ("a", "b", "c", "d"))) = }')
    #[(1, 'a'), (2, 'b'), (3, 'c')]

> zip() 与 * 运算符相结合可以用来拆解一个列表
```python
x = [1, 2, 3]
y = [4, 5, 6]
zipped = zip(x, y) #打包
print(list(zipped))#转为列表
print(*zip(x,y))   #解包可迭代对象
print(list(zip(*zip(x, y))))#解包后再次按元素序号打包
x2, y2 = zip(*zip(x, y))
print(x == list(x2) and y == list(y2))

# [(1, 4), (2, 5), (3, 6)]
# (1, 4) (2, 5) (3, 6)
# [(1, 2, 3), (4, 5, 6)]
# True
```

### 38. next()
* 格式：  `next(iterator[, default])`
* 返回值： 通过调用 iterator 的 __next__() 方法获取下一个元素。如果迭代器耗尽，则返回给定的 default，如果没有默认值则触发 StopIteration。
```python
class Iterator:
    def __init__(self):
        self.items = [1, 2, 3]
    def __iter__(self):
        return self
    def __next__(self):
        print('调用了__next__')
        if not self.items:
            raise StopIteration
        return self.items.pop(0)
iterator = Iterator()
print(f'{ next(iterator) = }')
print(f'{ next(iterator) = }')
print(f'{ next(iterator) = }')
# print(f'{ next(iterator) = }')
print(f'{ next(iterator, None) = }')
print(f'{ next(iterator, None) = }')

# 调用了__next__
#  next(iterator) = 1
# 调用了__next__
#  next(iterator) = 2
# 调用了__next__
#  next(iterator) = 3
# 调用了__next__
#  next(iterator, None) = None
# 调用了__next__
#  next(iterator, None) = None
```

### 39. iter()
* 格式： iter(object[, sentinel]) 
* 返回值：根据是否存在第二个实参，第一个实参的解释是非常不同的。如果没有第二个实参，object 必须是支持迭代协议（有 __iter__() 方法）的集合对象，或必须支持序列协议（有 __getitem__() 方法，且数字参数从 0 开始）。

### 40. reversed()
* 格式： reversed(seq)
* 返回值： 返回一个反向的 iterator。 seq 必须是一个具有 __reversed__() 方法的对象或者是支持该序列协议（具有从 0 开始的整数类型参数的 __len__() 方法和 __getitem__() 方法）。
```python
print(f'{ hasattr(list, "__reversed__") = }')
print(f'{ reversed(["a", "b", "c"]) = }')
print(f'{ list(reversed(["a", "b", "c"])) = }')
print('----------------')
print(f'{ hasattr(tuple, "__reversed__") = }')
print(f'{ hasattr(tuple, "__len__") = }')
print(f'{ hasattr(tuple, "__getitem__") = }')
print(f'{ reversed(("a", "b", "c")) = }')
print(f'{ tuple(reversed(("a", "b", "c"))) = }')
print('------------------')
print(f'{ hasattr(range, "__reversed__") = }')
print(f'{ reversed(range(3)) = }')
print(f'{ list(reversed(range(3))) = }')
print('----------------')
print(f'{ hasattr(str, "__reversed__") = }')
print(f'{ hasattr(str, "__len__") = }')
print(f'{ hasattr(str, "__getitem__") = }')
print(f'{ reversed("abc") = }')
print(f'{ list(reversed("abc")) = }')

'''
hasattr(list, "__reversed__") = True
reversed(["a", "b", "c"]) = <list_reverseiterator object at 0x000001349DB81C70>
list(reversed(["a", "b", "c"])) = ['c', 'b', 'a']
----------------
hasattr(tuple, "__reversed__") = False
hasattr(tuple, "__len__") = True
hasattr(tuple, "__getitem__") = True
reversed(("a", "b", "c")) = <reversed object at 0x000001349DB08400>
tuple(reversed(("a", "b", "c"))) = ('c', 'b', 'a')
------------------
hasattr(range, "__reversed__") = True
reversed(range(3)) = <range_iterator object at 0x00000134A012CDD0>
list(reversed(range(3))) = [2, 1, 0]
----------------
hasattr(str, "__reversed__") = False
hasattr(str, "__len__") = True
hasattr(str, "__getitem__") = True
reversed("abc") = <reversed object at 0x000001349DB08400>
list(reversed("abc")) = ['c', 'b', 'a']

'''
```

### 41. slice()
* 格式： class slice(start, stop[, step])
* 返回值： 返回一个表示由 `range(start, stop, step)` 所指定索引集的 slice 对象。 切片对象具有仅会返回对应参数值（或其默认值）的只读数据属性 start, stop 和 step。
> 其中 start 和 step 参数默认为 None。 切片对象具有仅会返回对应参数值（或其默认值）的只读数据属性 start, stop 和 step。 它们没有其他的显式功能；不过它们会被 NumPy 以及其他第三方扩展所使用。 切片对象也会在使用扩展索引语法时被生成。 例如: a[start:stop:step] 或 a[start:stop, i]。
```python
s=slice(3,10,2)
s1=slice(10)
x=np.arange(100)
print(x[3:10:2])
print(x[s])
print(x[s1])
# [3 5 7 9]
# [3 5 7 9]
# [0 1 2 3 4 5 6 7 8 9]
```
## 9. 对象操作
### 42. callable()
* 格式： callable(object)
* 返回值：如果参数 object 是可调用的就返回 True，否则返回 False。 如果返回 True，调用仍可能失败，但如果返回 False，则调用 object 将肯定不会成功。 请注意类是可调用的（调用类将返回一个新的实例）；如果实例所属的类有 __call__() 则它就是可调用的。

3.2 新版功能: 这个函数一开始在 Python 3.0 被移除了，但在 Python 3.2 被重新加入。
```python
# 如果参数 object 是可调用的就返回 True，否则返回 False。
print(f'{ callable(callable) = }')
def function():
    pass
print(f'{ callable(function) = }')
print(f'{ callable(123) = }')
print(f'{ callable("test") = }')
'''
callable(callable) = True
callable(function) = True
callable(123) = False
callable("test") = False
'''

# 请注意类是可调用的（调用类将返回一个新的实例）；
print('--------')
class C:
    pass
print(f'{ callable(C) = }')
'''
callable(C) = True
callable(C()) = False
'''

# 如果实例所属的类有 __call__() 则它就是可调用的。
print(f'{ callable(C()) = }')
print('--------')
class C:
    def __call__(self):
        return "test"
print(f'{ callable(C()) = }')
print(f'{ C()() = }')
'''
callable(C()) = True
C()() = 'test'
'''
```

### 43. hash()
hash(object)
返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。

注解 如果对象实现了自己的 __hash__() 方法，请注意，hash() 根据机器的字长来截断返回值。另请参阅 __hash__()

返回该对象的哈希值（如果它有的话）。哈希值是整数。
print(f'{ hash("test") = }')
print(f'{ hash("test") = }')
print(f'{ hash("test") = }')
print(f'{ hash((1, 2, 3)) = }')
print(f'{ hash(123456) = }')
相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。
print(f'{ hash(1) = }')
print(f'{ hash(1.0) = }')
print(f'{ hash(1+0j) = }')
print(f'{ hash(True) = }')

### 45. id()
* 格式： id(object)
* 返回值： 返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命期不重叠的对象可能具有相同的 id() 值。

```python

返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。
This is the address of the object in memory.
list_test = ["a", "b"]
print(f'{ id(list_test) = }')
print(f'{ hex(id(list_test)) = }')
str_test = "ab"
print(f'{ id(str_test) = }')
print(f'{ hex(id(str_test)) = }')
print('-------')
list_test.append("c")
print(f'{ id(list_test) = }')
str_test += "c"
print(f'{ id(str_test) = }')
引发一个 审计事件 builtins.id，附带参数 id。
import sys
def audit_hook(event, args):
    if event in ['builtins.id']:
        print(f'{ event = } { args = }')
sys.addaudithook(audit_hook)
print('------')
print(f'{ id("测试") = }')
```

### 46. len()
* 格式： len(s)
* 返回值： 返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。
```python
返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）。
print(f'{ len("abc") = }')
print(f'{ len(bytes("abc", "utf-8")) = }')
print(f'{ len(["a", "b", "c"]) = }')
print(f'{ len(("a", "b", "c")) = }')
print(f'{ len(range(3)) = }')
'''
len("abc") = 3
len(bytes("abc", "utf-8")) = 3
len(["a", "b", "c"]) = 3
len(("a", "b", "c")) = 3
len(range(3)) = 3
'''
print('------------')
print(f'{ len({"a":1, "b":2, "c":3}) = }')
print(f'{ len({"a", "b", "c"}) = }')
print(f'{ len(frozenset({"a", "b", "c"})) = }')
'''
len({"a":1, "b":2, "c":3}) = 3
len({"a", "b", "c"}) = 3
len(frozenset({"a", "b", "c"})) = 3
'''
```
### 47. object()
* 格式： class object
* 返回值： 返回一个没有特征的新对象。object 是所有类的基类。它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。

> 由于 object 没有 __dict__，因此无法将任意属性赋给 object 的实例
```python
#返回一个没有特征的新对象。
print(f'{ object() = }')
# object() = <object object at 0x000001587A5B0300>

#object 是所有类的基类。它具有所有 Python 类实例的通用方法。
print(f'{ object().__str__() = }')
print(f'{ object().__repr__() = }')
print(f'{ object().__hash__() = }')
print(f'{ object().__dir__() = }')
'''
object().__str__() = '<object object at 0x000001587A5B0300>'
object().__repr__() = '<object object at 0x000001587A5B0300>'
object().__hash__() = 92470095920
object().__dir__() = ['__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__init__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__', '__doc__']
'''
#由于 object 没有 __dict__，因此无法将任意属性赋给 object 的实例
print(f'{ hasattr(object, "__dict__") = }')
print(f'{ hasattr(object(), "__dict__") = }')
x = object()
x.test = 123
setattr(x, 'test', 123)
'''
hasattr(object, "__dict__") = True
hasattr(object(), "__dict__") = False
AttributeError: 'object' object has no attribute 'test'
'''
```
### 48. delattr(object, name)
实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。
### 49. getattr(object, name[, default])
返回对象命名属性的值。name 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。 
### 50. hasattr(object, name)
该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 True，否则返回 False。
### 51. setattr(object, name, value)
此函数与 getattr() 两相对应。 其参数为一个对象、一个字符串和一个任意值。 字符串指定一个现有属性或者新增属性。 函数会将值赋给该属性，只要对象允许这种操作。 例如，setattr(x, 'foobar', 123) 等价于 x.foobar = 123。

## 10. 类与实例
### 52. isinstance()
* 格式： isinstance(object, classinfo)
* 返回值： 如果参数 object 是参数 classinfo 的实例或者是其 (直接、间接或 虚拟) 子类则返回 True。 如果 object 不是给定类型的对象，函数将总是返回 False。 
> 如果 classinfo 是类型对象元组（或由其他此类元组递归组成的元组），那么如果 object 是其中任何一个类型的实例就返回 True。 如果 classinfo 既不是类型，也不是类型元组或类型元组的元组，则将引发 TypeError 异常

```python
# 如果参数 object 是参数 classinfo 的实例或者是其 (直接、间接或 虚拟) 子类则返回 True。
print(f'{ isinstance(True, bool) = }')
print(f'{ isinstance(123, int) = }')
print(f'{ isinstance("test", str) = }')
print('----')
class A:
    pass
class B(A):
    pass
class C(B):
    pass
c = C()
print(f'{ isinstance(c, C) = }')
print(f'{ isinstance(c, B) = }')
print(f'{ isinstance(c, A) = }')
#  如果 object 不是给定类型的对象，函数将总是返回 False。
print('------')
print(f'{ isinstance(123, str) = }')
print(f'{ isinstance("test", bool) = }')
#  如果 classinfo 是类型对象元组（或由其他此类元组递归组成的元组），那么如果 object 是其中任何一个类型的实例就返回 True。
print('---------')
print(f'{ isinstance("test", (bool, int)) = }')
print(f'{ isinstance("test", (bool, int, str)) = }')
print(f'{ isinstance("test", (bool, (int, float, complex), (str, (bytes, bytearray)))) = }')

#  如果 classinfo 既不是类型，也不是类型元组或类型元组的元组，则将引发 TypeError 异常
print('---------')
# print(f'{ isinstance("test", "test") = }')
print(f'{ isinstance("test", [bool, int, str]) = }')
```

### 53. issubclass()
* 格式： issubclass(class, classinfo)
* 返回值： 如果 class 是 classinfo 的 (直接、间接或 虚拟) 子类则返回 True。 类会被视作其自身的子类。 classinfo 也以是类对象的元组，在此情况下 classinfo 中的每个条目都将被检查。 在任何其他情况下，都将引发 TypeError 异常。
```python
# 如果 class 是 classinfo 的 (直接、间接或 虚拟) 子类则返回 True。
class A:
    pass
class B(A):
    pass
class C(B):
    pass
print(f'{ issubclass(B, A) = }')
print(f'{ issubclass(C, B) = }')
print(f'{ issubclass(C, A) = }')
print(f'{ issubclass(C, int) = }')
# 类会被视作其自身的子类。
print('---')
print(f'{ issubclass(A, A) = }')
# classinfo 也以是类对象的元组，在此情况下 classinfo 中的每个条目都将被检查。
print('-----')
print(f'{ issubclass(B, (int, str)) = }')
print(f'{ issubclass(B, (int, str, A)) = }')
print(f'{ issubclass(B, (int, str, (float, A))) = }')
# 在任何其他情况下，都将引发 TypeError 异常。
print('-----------')
# print(f'{ issubclass(B, 123) = }')
# print(f'{ issubclass(B, [int, str, A]) = }')
```

### 54. type()
* 格式： class type(object)
class type(name, bases, dict)

* 返回值： 传入一个参数时，返回 object 的类型。 返回值是一个 type 对象，通常与 object.__class__ 所返回的对象相同。
```python
# 传入一个参数时，返回 object 的类型。 返回值是一个 type 对象，通常与 object.__class__ 所返回的对象相同。
print(f'{ type("test") = }')
print(f'{ type(type("test")) = }')
print(f'{ "test".__class__ = }')
print(f'{ "test".__class__ == type("test") = }')
#
# 推荐使用 isinstance() 内置函数来检测对象的类型，因为它会考虑子类的情况。
#
# 传入三个参数时，返回一个新的 type 对象。 这在本质上是 class 语句的一种动态形式。 name 字符串即类名并且会成为 __name__ 属性；bases 元组列出基类并且会成为 __bases__ 属性；而 dict 字典为包含类主体定义的命名空间并且会被复制到一个标准字典成为 __dict__ 属性。
class Animal: pass
class Pet: pass
# class Cat(Animal, Pet):
#     name = "小猫"
#     age = 0
#     def get_info(self):
#         return f'小猫名字叫{self.name}，今年{self.age}岁。'
def get_info(self):
    info = f'小猫名字叫{self.name}，今年{self.age}岁。'
    return info
Cat = type('Cat',
     (Animal, Pet),
     # dict(name="小猫", age=0, get_info=lambda self: f'小猫名字叫{self.name}，今年{self.age}岁。')
     dict(name="小猫", age=0, get_info=get_info)
)
print('-----')
cat = Cat()
print(f'{ Cat.__name__ = }')
print(f'{ Cat.__bases__ = }')
print(f'{ Cat.__dict__ = }')
# print(f'{ cat.name = }')
# print(f'{ cat.age = }')
# print(f'{ cat.get_info() = }')

#
#
# 例如，下面两条语句会创建相同的 type 对象:
#
# >>>
# class X:
#     a = 1
#
# X = type('X', (object,), dict(a=1))
# 另请参阅 类型对象。
#
# 在 3.6 版更改: type 的子类如果未重载 type.__new__，将不再能使用一个参数的形式来获取对象的类型。
```

## 11. 装饰器、描述器
### 55. classmethod()
* 格式： @classmethod
* 返回值： 把一个方法封装成类方法。
```python
# 一个类方法把类自己作为第一个实参，就像一个实例方法把实例自己作为第一个实参。请用以下习惯来声明类方法:
# class C:
#     @classmethod
#     def f(cls, arg1, arg2, ...): ...
# @classmethod 这样的形式称为函数的 decorator -- 详情参阅 函数定义。
class C:
    @classmethod
    def f(*args):
        print(f'{ args = }')
print(f'{ C.f = }')
C.f()

# 类方法的调用可以在类上进行 (例如 C.f()) 也可以在实例上进行 (例如 C().f())。 其所属类以外的类实例会被忽略。 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。
# 
# 类方法的调用可以在类上进行 (例如 C.f()) 也可以在实例上进行 (例如 C().f())。 其所属类以外的类实例会被忽略。
class C:
    @classmethod
    def f(*args):
        print(f'{ args = }')
print('-'*20)
C.f()
C().f()
# 如果类方法在其所属类的派生类上调用，则该派生类对象会被作为隐含的第一个参数被传入。
class D(C):
    pass
print('-'*20)
D.f()

# 类方法与 C++ 或 Java 中的静态方法不同。 如果你需要后者，请参阅本节中的 staticmethod()。 有关类方法的更多信息，请参阅 标准类型层级结构。
# 
# 注意点：@classmethod是一个装饰器，Python的装饰器可以像常规函数一样调用，所以classmethod可以像常规函数一样调用
class C:
    # @classmethod
    def f(*args):
        print(f'{ args = }')
    f = classmethod(f)
print('-'*20)
C.f()

# 在 3.9 版更改: 类方法现在可以包装其他 描述器 例如 property()。

# 在 3.9 版更改: 类方法现在可以包装其他 描述器 例如 property()。
# 这句话有个隐含的信息，classmethod()是一个描述器
# Python规定任何定义了__get__ __set__ __delete__特殊方法的类为描述器类，描述器类的实例是描述器
class C:
    def f(*args):
        print(f'{ args = }')
    f = classmethod(f)
print('-'*20)
print(f'{ C.f = }')
print(f'{ C.__dict__["f"] = }')
print(f'{ C.__dict__["f"].__get__(None, C) = }')
print(f'{ C.__dict__["f"].__get__(None, C) == C.f = }')

```

### 56. property()
* 格式： class property(fget=None, fset=None, fdel=None, doc=None)
* 返回值： 返回 property 属性。
```python
# fget 是获取属性值的函数。 fset 是用于设置属性值的函数。 fdel 是用于删除属性值的函数。并且 doc 为属性对象创建文档字符串。
# 一个典型的用法是定义一个托管属性 x:
# class C:
#     def __init__(self):
#         self._x = None
#
#     def getx(self):
#         return self._x
#
#     def setx(self, value):
#         self._x = value
#
#     def delx(self):
#         del self._x
#     x = property(getx, setx, delx, "I'm the 'x' property.")
# 如果 c 是 C 的实例，c.x 将调用getter，c.x = value 将调用setter， del c.x 将调用deleter。
class C:
    def __init__(self):
        self._x = None
    def setx(self, value):
        print(f'调用了setx {  value = }')
        self._x = value
    def delx(self):
        print('调用了delx')
        del self._x
    def getx(self):
        """这是x属性的文档"""
        print('调用了getx')
        return self._x
    # 如果 c 是 C 的实例，c.x 将调用getter，c.x = value 将调用setter， del c.x 将调用deleter。
    # x = property(getx, setx, delx, "I'm the 'x' property.")
    x = property(getx, setx, delx)
c = C()
# print(f'{ c.x = }')
# c.x = 123
# del c.x
# print(f'{ C.x.__doc__ = }')
#
# 如果给出，doc 将成为该 property 属性的文档字符串。 否则该 property 将拷贝 fget 的文档字符串（如果存在）。 这令使用 property() 作为 decorator 来创建只读的特征属性可以很容易地实现:
# class Parrot:
#     def __init__(self):
#         self._voltage = 100000
#     @property
#     def voltage(self):
#         """Get the current voltage."""
#         return self._voltage
# 以上 @property 装饰器会将 voltage() 方法转化为一个具有相同名称的只读属性的 "getter"，并将 voltage 的文档字符串设置为 "Get the current voltage."
class Parrot:
    def __init__(self):
        self._voltage = 100000
    @property
    def voltage(self):
        """Get the current voltage."""
        print('调用了voltage的getter')
        return self._voltage
    # voltage = property(voltage)
parrot = Parrot()
# print(f'{ parrot.voltage = }')
# print(f'{ Parrot.voltage.__doc__ = }')
# parrot.voltage = 200000
#
# 特征属性对象具有 getter, setter 以及 deleter 方法，它们可用作装饰器来创建该特征属性的副本，并将相应的访问函数设为所装饰的函数。 这最好是用一个例子来解释:
# class C:
#     def __init__(self):
#         self._x = None
#     @property
#     def x(self):
#         """I'm the 'x' property."""
#         return self._x
#     @x.setter
#     def x(self, value):
#         self._x = value
#     @x.deleter
#     def x(self):
#         del self._x
# 上述代码与第一个例子完全等价。 注意一定要给附加函数与原始的特征属性相同的名称 (在本例中为 x。)
# 返回的特征属性对象同样具有与构造器参数相对应的属性 fget, fset 和 fdel。
# 在 3.5 版更改: 特征属性对象的文档字符串现在是可写的。
# class C:
#     def __init__(self):
#         self._x = None
#     def getx(self):
#         return self._x
#     def setx(self, value):
#         self._x = value
#     def delx(self):
#         del self._x
#     x = property(getx, setx, delx, "I'm the 'x' property.")
class C:
    def __init__(self):
        self._x = None
    @property
    def x(self):
        """I'm the 'x' property."""
        print('获取属性')
        return self._x
    # x = property(x)
    @x.setter
    def x(self, value):
        print('设置属性')
        self._x = value
    # x = x.setter(x)
    @x.deleter
    def x(self):
        print('删除属性')
        del self._x
    # x = x.deleter(x)
print('-'*20)
c = C()
# c.x
# c.x = 123
# del c.x

class C:
    def __init__(self):
        self._x = None
    # @property
    def x(self):
        """I'm the 'x' property."""
        print('获取属性')
        return self._x
    x = property(x)
    # @x.setter
    def temp_x(self, value):
        print('设置属性')
        self._x = value
    x = x.setter(temp_x)
    # @x.deleter
    def temp_x(self):
        print('删除属性')
        del self._x
    x = x.deleter(temp_x)
print('-'*20)
c = C()
c.x
c.x = 123
del c.x
```
### 57. staticmethod()
* 格式： @staticmethod
* 返回值： 将方法转换为静态方法。
```python
# 静态方法不会接收隐式的第一个参数。要声明一个静态方法，请使用此语法
#
# class C:
#     @staticmethod
#     def f(arg1, arg2, ...): ...
# @staticmethod 这样的形式称为函数的 decorator -- 详情参阅 函数定义。
class C:
    @staticmethod
    def f(*args):
        print(f'{ args = }')
C.f()
C().f()
# 静态方法的调用可以在类上进行 (例如 C.f()) 也可以在实例上进行 (例如 C().f())。
#
# Python中的静态方法与Java或C ++中的静态方法类似。另请参阅 classmethod() ，用于创建备用类构造函数的变体。
#
# 像所有装饰器一样，也可以像常规函数一样调用 staticmethod ，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。对于这些情况，请使用此语法:
#
# class C:
#     builtin_open = staticmethod(open)
# 想了解更多有关静态方法的信息，请参阅 标准类型层级结构 。

# 像所有装饰器一样，也可以像常规函数一样调用 staticmethod ，并对其结果执行某些操作。比如某些情况下需要从类主体引用函数并且您希望避免自动转换为实例方法。
class C:
    # @staticmethod
    def f(*args):
        print(f'{ args = }')
    f = staticmethod(f)
    builtin_abs = staticmethod(abs)
print('-'*20)
C.f()
print(f'{ C.builtin_abs(-5) = }')
```

## 12. 代码编译与执行

### 58. eval()
* 格式: eval(expression[, globals[, locals]])
* 返回值: 返回对字符串的解析结果
> 实参是一个字符串，以及可选的 globals 和 locals。globals 实参必须是一个字典。locals 可以是任何映射对象。

```python
a = 1
b = 2
print(f'{ eval("np.linspace(0,b,5)") = }')
print(f'{ eval("a+b") = }')
print(f'{ eval("a+b", dict(a=5, b=6)) = }')
c,d=eval(input())

'''
eval("np.linspace(0,b,5)") = array([0. , 0.5, 1. , 1.5, 2. ])
eval("a+b") = 3
eval("a+b", dict(a=5, b=6)) = 11
12,36
'''
```

### 59. complie()
* 格式: `compile(source, filename, mode, flags=0, dont_inherit=False, optimize=- 1)`

将 source 编译成代码或 AST 对象。代码对象可以被 exec() 或 eval() 执行。source 可以是常规的字符串、字节字符串，或者 AST 对象。参见 ast 模块的文档了解如何使用 AST 对象。
filename 实参需要是代码读取的文件名；如果代码不需要从文件中读取，可以传入一些可辨识的值（经常会使用 '<string>'）。
mode 实参指定了编译代码必须用的模式。如果 source 是语句序列，可以是 'exec'；如果是单一表达式，可以是 'eval'；如果是单个交互式语句，可以是 'single'。（在最后一种情况下，如果表达式执行结果不是 None 将会被打印出来。）

```python
# 将 source 编译成代码或 AST 对象。
# source 可以是常规的字符串
# filename 可以传入一些可辨识的值（经常会使用 '<string>'）
# mode 实参指定了编译代码必须用的模式。如果 source 是语句序列，可以是 'exec'；
# 代码对象可以被 exec() 或 eval() 执行。
src = """
for i in range(3):
    print(i)
"""
print(f'{ compile(src, "<string>", "exec") = }')
exec(compile(src, "<string>", "exec"))
# mode 如果是单一表达式，可以是 'eval'；
print(f'{ compile("1+2+3", "<string>", "eval") = }')
print(f'{ eval(compile("1+2+3", "<string>", "eval")) = }')
# mode 如果是单个交互式语句，可以是 'single'。
# src = "name=input('请输入你的名字：')"
# exec(compile(src, "<string>", "single"))
# print(f'{ name = }')
# source 可以是常规的字符串、字节字符串，或者 AST 对象。
print('---------')
src = bytes("print('test')", "utf-8")
print(f'{ compile(src, "<bytes>", "exec") = }')
exec(compile(src, "<bytes>", "exec"))
print('---------')
import ast
src = ast.parse("print('abc')")
print(f'{ compile(src, "<ast>", "exec") = }')
exec(compile(src, "<ast>", "exec"))
# 将 source 编译成代码或 AST 对象。
print('----------')
src = "print(123)"
print(f'{ compile(src, "<string>", "exec", flags=ast.PyCF_ONLY_AST) = }')
```

编译器选项和 future 语句是由比特位来指明的。 比特位可以通过一起按位 OR 来指明多个选项。 指明特定 future 特性所需的比特位可以在 __future__ 模块的 _Feature 实例的 compiler_flag 属性中找到。 编译器旗标 可以在 ast 模块中查找带有 PyCF_ 前缀的名称。

optimize 实参指定编译器的优化级别；默认值 -1 选择与解释器的 -O 选项相同的优化级别。显式级别为 0 （没有优化；__debug__ 为真）、1 （断言被删除， __debug__ 为假）或 2 （文档字符串也被删除）。

如果编译的源码不合法，此函数会触发 SyntaxError 异常；如果源码包含 null 字节，则会触发 ValueError 异常。

引发一个 审计事件 compile 附带参数 source, filename。

注解 在 'single' 或 'eval' 模式编译多行代码字符串时，输入必须以至少一个换行符结尾。 这使 code 模块更容易检测语句的完整性。
警告: 在将足够大或者足够复杂的字符串编译成 AST 对象时，Python 解释器有可能因为 Python AST 编译器的栈深度限制而崩溃。

### 60. exec()
* 格式: exec(object[, globals[, locals]])
* 返回值: None
> 这个函数支持动态执行 Python 代码。object 必须是字符串或者代码对象。如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。
```python
exec("for i in range(3): print(i)")
# 如果是代码对象，它将被直接执行。
print('-----------')
print(f'{ compile("for i in range(3): print(i)", "<string>", "exec") = }')
print('-----------')
exec(compile("for i in range(3): print(i)", "<string>", "exec"))

# 这个函数支持动态执行 Python 代码。object 必须是字符串或者代码对象。如果是字符串，那么该字符串将被解析为一系列 Python 语句并执行（除非发生语法错误）。1 如果是代码对象，它将被直接执行。在任何情况下，被执行的代码都需要和文件输入一样是有效的（见参考手册中关于文件输入的章节）。请注意即使在传递给 exec() 函数的代码的上下文中，return 和 yield 语句也不能在函数定义之外使用。该函数返回值是 None 。
#
# 无论哪种情况，如果省略了可选项，代码将在当前作用域内执行。 如果只提供了 globals，则它必须是一个字典（不能是字典的子类），该字典将同时被用于全局和局部变量。 如果同时提供了 globals 和 locals，它们会分别被用于全局和局部变量。 如果提供了 locals，则它可以是任何映射对象。 请记住在模块层级上，globals 和 locals 是同一个字典。 如果 exec 得到两个单独对象作为 globals 和 locals，则代码将如同嵌入类定义的情况一样执行。

# # 无论哪种情况，如果省略了可选项，代码将在当前作用域内执行。 如果只提供了 globals，则它必须是一个字典（不能是字典的子类），该字典将同时被用于全局和局部变量。
a = 2
b = 3
print('---------')
exec("print(a*b)")
print('---------')
exec("print(a*b)", dict(a=5, b=6))
```

## 13. 可打印表示形式字符串
### 61. repr()
* 格式: repr(object)
* 返回值: printable
> 返回包含一个对象的可打印表示形式的字符串。
```python
print(f'{ repr(123) = }')
print(f'{ str(123) = }')
print(f'{ repr(1.23) = }')
print(f'{ str(1.23) = }')
print(f'{ repr([1, 2, 3]) = }')
print(f'{ str([1, 2, 3]) = }')
print('------')
print(f'{ repr("abc") = }')
print(f'{ str("abc") = }')
print('------')
print(
    len(repr("abc")),
    len(str("abc")),
    repr("abc")[0],
    repr("a\"bc")[0],
    repr("a'bc")[0],
    repr("a'\"bc")[0],
)
print('------')
import datetime
date_test = datetime.date(year=1970, month=1, day=1)
print(f'{ repr(date_test) = }')
print(f'{ str(date_test) = }')

# repr(123) = '123'
# str(123) = '123'
# repr(1.23) = '1.23'
# str(1.23) = '1.23'
# repr([1, 2, 3]) = '[1, 2, 3]'
# str([1, 2, 3]) = '[1, 2, 3]'
# ------
# repr("abc") = "'abc'"
# str("abc") = 'abc'
# ------
# 5 3 ' ' " '
# ------
# repr(date_test) = 'datetime.date(1970, 1, 1)'
# str(date_test) = '1970-01-01'
```

> 对于许多类型来说，该函数会尝试返回的字符串将会与该对象被传递给 eval() 时所生成的对象具有相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包含对象类型的名称与通常包括对象名称和地址的附加信息。 类可以通过定义 __repr__() 方法来控制此函数为它的实例所返回的内容。

```python
print(f'{ eval(repr(123)) = }')
print(f'{ eval(repr(123)) == 123 = }')
print(f'{ eval(repr("test")) = }')
print(f'{ eval(repr("test")) == "test" = }')
print(f'{ eval(repr([1, 2, 3])) = }')
print(f'{ eval(repr([1, 2, 3])) == [1, 2, 3] = }')

# eval(repr(123)) = 123
# eval(repr(123)) == 123 = True
# eval(repr("test")) = 'test'
# eval(repr("test")) == "test" = True
# eval(repr([1, 2, 3])) = [1, 2, 3]
# eval(repr([1, 2, 3])) == [1, 2, 3] = True
```

### 62. ascii()
* 格式: ascii(object)
* 返回值: 返回一个对象可打印的字符串
> repr() 返回的字符串中非 ASCII 编码的字符，会使用 \x、\u 和 \U 来转义。

```python
print(f'{ ascii(123) = }')
print(f'{ repr(123) = }')
print(f'{ ascii(1.23) = }')
print(f'{ repr(1.23) = }')
print(f'{ ascii("test") = }')
print(f'{ repr("test") = }')
print(f'{ ascii([1, 2, 3]) = }')
print(f'{ repr([1, 2, 3]) = }')
# Unciode码点(码位、编号)
#     0~127 ASCII字符，不会使用\x \u \U转义字符
#     128~255 会使用\x转义字符
#     256~65535 会使用\u转义字符
#     65536~0x10ffff 会使用\U转义字符
print('---------')
print(f'{ ascii("test©汉😎") = }')
print(f'{ repr("test©汉😎") = }')
print(f'{ ascii(["test", "©", "汉", "😎"]) = }')
print(f'{ repr(["test", "©", "汉", "😎"]) = }')

# ascii(123) = '123'
# repr(123) = '123'
# ascii(1.23) = '1.23'
# repr(1.23) = '1.23'
# ascii("test") = "'test'"
# repr("test") = "'test'"
# ascii([1, 2, 3]) = '[1, 2, 3]'
# repr([1, 2, 3]) = '[1, 2, 3]'
# <class 'str'>
# ascii("test©汉😎") = "'test\\xa9\\u6c49\\U0001f60e'"
# repr("test©汉😎") = "'test©汉😎'"
# ascii(["test", "©", "汉", "😎"]) = "['test', '\\xa9', '\\u6c49', '\\U0001f60e']"
# repr(["test", "©", "汉", "😎"]) = "['test', '©', '汉', '😎']"
```

## 14. 其他
### 63. help()
启动内置的帮助系统（此函数主要在交互式中使用）。如果没有实参，解释器控制台里会启动交互式帮助系统。
如果实参是一个字符串，则在模块、函数、类、方法、关键字或文档主题中搜索该字符串，并在控制台上打印帮助信息。
如果实参是其他任意对象，则会生成该对象的帮助页。

### 64. super()
super() 函数是用于调用父类(超类)的一个方法。

### 65. locals()
> 更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 locals() 时将返回自由变量。 请注意在模块层级上，locals() 和 globals() 是同一个字典。

> 注解 不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。
```python
# 更新并返回表示当前本地符号表的字典。 在函数代码块但不是类代码块中调用 locals() 时将返回自由变量。
def f(arg):
    v = 0
    def f_test():
        pass
    class C():
        pass
    print(f'{ locals() = }')
f(1)
# 请注意在模块层级上，locals() 和 globals() 是同一个字典。
print('--------')
print(f'{ locals() == globals() = }')
# 注解 不要更改此字典的内容；更改不会影响解释器使用的局部变量或自由变量的值。
def f(arg):
    v = 0
    def f_test():
        pass
    class C():
        pass
    locals()['v'] = 3
    print(f'{ v = }')
    print(f'{ locals() = }')
print('------------')
f(1)
```
### 66. globals()

> 返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。
```python
# 返回表示当前全局符号表的字典。
import sys
v = 0
def f(): pass
class C(): pass
print(f'{ globals() = }')
# 这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。
import module_test
print('----------------------')
module_test.f1()
print('----------------------')
module_test.C1().m1()

# module test
# v1 = 0
# def f1():
#     print(f'{ globals() = }')
# class C1():
#     def m1(self):
#         print(f'{ globals() = }')
```

### 67. vars()
vars() 函数返回对象object的属性和属性值的字典对象。

### 68. dir()
* 格式：`dir([object]) -> list of strings`

>如果没有实参，则返回当前本地作用域中的名称列表。如果有实参，它会尝试返回该对象的有效属性列表。

函数 dir() 用于查找模块定义的名称。返回结果是经过排序的字符串列表。

dir函数可以列出对象的模块标识符，标识符有函数、类和变量。当你为dir函数提供一个模块名的时候，它返回模块定义的名称列表。如果不提供参数，它返回当前模块中定义的名称列表。

### 69. reload()
用于重新载入之前载入的模块。